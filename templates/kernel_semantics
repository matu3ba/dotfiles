Overview of Kernel use case groups
- eexcution environments (kernel [task, module, virtual machine], user [process, thread])
- inter process communication (pipe, io_uring?, locks, shared memory, signals, sockets, streams, wait groups, ..)
- io management (block, io_uring, stream, virtual device access, ..)
- memory management (kernel, stack, heap, paging [if CPU has MMU, PMU], ..)
- permission and access management
- time management (hardware timers, scheduling, sleeps/timeouts, set/get current time, ..)

Motivators for acceptable implementation design + complexity +
applicable/required formal methods
- time management: Accepted worst case execution time
- permission and access management: Accepted degree of security configurations (static,
  kernel-dynamic, user-dynamic, etc) and threat levels
- available hardware
- accepted performance loss (work per time)
- user-configurability of aforementioned points

List of fundamental and (in practice) unfixable design flaws
- tty underspecified + error prone plus a huge attack vector
  * why: multi-purpose stateful, (on unix) in-band, high-perf control + data
    transmission without single formal specification (as state automaton)
  * https://www.gresearch.com/blog/article/g-research-the-terminal-escapes/
  * https://vt100.net/emu/dec_ansi_parser
  * https://arcan-fe.com/2022/04/02/the-day-of-a-new-command-line-interface-shell/
  * "A tempest in a tty pot" https://lwn.net/Articles/343828/
- Unix io management: TODO
- file system [not representative of hardware, unsecure for overall tty+shell usage]
- ipc: no way to "flush" stdout/stderr to parent process
  * relevant, to identify/trace where child got stuck or terminates unexpectedly (intermediate results)
    + separate channel to signal message ready
    + non-blocking read + message length encoding
    + blocking read with timeout (aka poll) + message length encoding
- Unix signaling: racy unless from/with parent process or pid 1
  * (pid, gid, uuid) could be used as unique identification
  * (non)cooperative scheduling could use suspension points + Kernel watchdog
    with suspension points being necessary async events and watchdog being
    updated on every scheduler iteration
    + leaks (hardware) time information or requires configurable timesteps over it
- Unix? file permission system stores information within each file instead of file group
  * nested overlayfs has limit 6 blocking usage to make nix on Linux less path hacky
- Linux/Unix clone forces copy of whole memory, file descriptors etc (needed on
  partial usage), which is a footgun leading to resource leakage,
  synchronization problems and security problems
  * feasibility of full process control of caller unclear
  * how Kernel versioning could work very unclear, because Linux keeps the call
    ABI stable

idea citations for everything

mini kernel
https://github.com/nuta/operating-system-in-1000-lines
