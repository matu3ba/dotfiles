Force static linking:
gcc/g++ -static -static-libstdc++ -static-libgcc

Cross-compiling C++:
```sh
sudo apt-get install g++-VERSION-multilib-arm-linux-gnueabihf
export LD=arm-linux-gnueabihf-ld
export CXX=arm-linux-gnueabihf-g++-VERSION
export CXX_FLAGS="-static -static-libstdc++ -static-libgcc"
make -C builddir
```
ldd may stll falsely claim on host system, that the executable is statically build.
Alternative: buildchroot or zig

or fix the problem with the build system (include guards/linker scripts etc)

undefined symbols
nm -gD yourLib.so
C++ demangling
nm -gDC yourLib.so
nm yourlib | c++filt

linking
-Iincludepath
-llibrary

However, the library may be already in your system paths.

When a library is scanned by the linker, only functions for which there
are already undefined references are linked. So you need to put the "consuming"
objects at the start of the link line, and the "supplying" objects at the end.

idea: instructions on how to debug lld etc

objdump -h to dump section list
objdump --help | vi

extern only, demangle
nm -g -C build/stage3/bin/zig

`nm` - show symbol table of an object or library.
`gcc -###` - gcc shows full commands it passes to the underlying tools.

https://maskray.me/blog/2021-12-19-why-isnt-ld.lld-faster

Tracing linker
mold -run make --trace
ld --trace
lld --trace
