Best Practice taken from "Large Scale Architecture: The Unreasonable Effectiveness of Simplicity - Randy Shoup"

Test-Driven Development
* inbox zero for bugs (immediately fixed, when they come up)
* feature flags to [dis|en]able feature for particular set of users
=> decouple feature delivery from code delivery

"All of the pain that we feel when writing unit tests points at underlying
design problems."
=> Integration Testing is hard (especially time scaling for simulation + translation to real system).
=> Unit testing *must* be easy.

Continuous Delivery
* iteratively identify and remove bottlenecks for teams
* "what would it take to deploy application every day?"
* 3x-5x improvements in deployment frequency, lead time, change failure rate, mean-time-to-restore

Simple transactions
* Dont use "distributed transactions".
* Model transaction as state machine of successive atomic events (workflow)
* Roll back with compensating operations in reverse
* Explicitly expose intermediate states in the interface

* Consider event-driven "dataflow" depending on architecture

Known bad designs:
- 1. googlemock forces to use default constructors and has horrible error messages with huge boilerplate
  * use injection instead
- 2. qtest / test frameworks are very verbose
  * use own test framework or language ones, unless specific use cases can be isolated
- 3. data driven tests via macros is the same as using a table without understandable error messages.
  * use a table + for loop instead
- 4. tight coupling of unrelated components
  * use weak coupling, if feasible
- 5. no unnecessary classes / boilerplate
  * dont decouple strongly related things, because classes create costs via pointer indirection

ideas for the ideal cli test system for non-timing and timing based testing:

- design rules to distinguish observable behavior without timing from
  timing-related behavior and how to work around that
- design rules for making a multi-threaded/process tool (piecewise) deterministically
  to write test queries for the collected data of the behavior
- test system for multi-threaded/process time based test collection and human output

- Query system options for test behavior: You are basically writing a RAM database
  best TODO intro
- Make it stupidly simple.

TODO explain property based testing, metamorphic testic
https://github.com/cryptocode/marble
https://www.cockroachlabs.com/blog/metamorphic-testing-the-database/
