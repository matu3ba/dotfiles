https://reproducible-builds.org/tools/
diffoscope - https://diffoscope.org/
rebuilderd - https://github.com/kpcyrd/rebuilderd

fd-find from sharkdp https://github.com/sharkdp/fd
fz from natecraddock https://github.com/natecraddock/zf
jfind from jake-stewart https://github.com/jake-stewart/jfind
qemu on iOS and macOS: https://github.com/utmapp/UTM
reverse engineering: https://rada.re/n/
ripgrep from BurntSushi https://github.com/BurntSushi/ripgrep
rr - https://github.com/rr-debugger/rr
znvim from LordMZTE https://mzte.de/git/LordMZTE/znvim (glpv3)
zellij: s-e (scrollback-edit)
yazi as file manager (https://github.com/sxyazi/yazi)

build system respecting unused files and detect parallel-unsafe build description (db can become huge): tup
shell: fish, crush-shell
terminal: contour, ghostty
editors: neovim[more plugins], vim[stable+no surprises], helix[lazy setup, few plugins], kakoune

fdupes or fork jdupes - finding duplicates
fdupes -qdN -r /ops/backup/

xpack for windows reproducible build framework (https://xpack.github.io/)
rizin - reverse debugging
grafana - visualization
windirstat for directory overview - https://windirstat.net/

xml parser: yxml https://code.blicky.net/yorhel/yxml
disk usage explorer: ncdu https://code.blicky.net/yorhel/ncdu or KDE filelight
simple header testing framework: utest.h https://github.com/sheredom/utest.h

proprietary
whitebox - program execution tracer and visualizer
tracy -- frame tracer and visualizer

- valgrind
* cachegrind: cache profiler
* callgrind: cachegrind + call graphs
* massif: heap profiler (massif-visualizer as graphical frontend)
* helgrind: race condition finder
* DRD: like helgrind, but uses less memory
* Lackey/None: demo/unit test of valgrind itself

C/C++
-- clang --
scan-build
clang-fmt
clang-tidy
flags compile-time: -Wthread-safety

https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind
clang -g -fsanitize=address foo.c
gcc -g -fsanitize=address -static-libasan foo.c
>slowdown by 2x-4x ASAN vs 20x-50x valgrind 10.000x gdb
>different types of errors
>TSAN 9x sanitizer - 404x valgrind slowdown
>slowdown with rr is <=1.2x but only runnable on single core
>"Vidi: Record Replay for Reconfigurable Hardware" looks ok,
>but there is nothing easily [re]usable yet.

(false positives with fortification)
__attribute__((no_sanitize_address))

clang -fsanitize=address,undefined a.c
clang -fsanitize=fuzzer,undefined -fno-sanitize-recover a.c
clang -fsanitize=hwaddress,undefined a.c
clang -fsanitize=memory,undefined a.c
clang -fsanitize=thread,undefined a.c
clang -fsanitize=cfi,undefined -flto -fvisibility=hidden a.c

-D_FORTIFIY_SOURCE={0,1,2}
adds checks to memory, copy printf functions
-D_FORTIFIY_SOURCE=2
default on many modern distros

ftrace
cat /sys/kernel/debug/tracing/trace
trace-cmd record -e tcp:tcp_destroy_sock
trace-cmd report

ltrace (dynamic library calls of process)
ltrace cmd
ltrace -w=4 cmd
ltrace -t cmd
ltrace -l libc.so* c
ltrace -e malloc+free-@libc.so* cmd

To get an overview: sudo tiptop

perf trace
perf trace cmd
perf trace -p 1234
perf trace -e read*
perf trace -D 500
perf trace record
perf script
perf report

gdb
record btrace

after core dump:
ls -ltm core*
gdb -c core.NUM
bt

gdb ./exec
record
break main
command 1
>record
>continue
>end
break exit
command 2
run
end
set pagination off
set confirm off
c

gdb ./exec
bt
reverse-stepi
disas
print $rsp
x $1
print /x * (unsigned long*) $sp
disas (printed thing)
x (disassembled thing)

            Linux tracing overview
___________________________________________________________________
addons+viewers           | trace_cmd, perf-tools, LTTng, kerneshark
front-end tools          | perf
tracing frameworks       | ftrace, perf_event, eBPF
Back-end instrumentation | tracepoints, kprobes, uprobes
source: https://wiki.st.com/stm32mpu/wiki/Linux_tracing,_monitoring_and_debugging

Embedded (mutli-partition swapping)
https://sbabic.github.io/swupdate/swupdate.html

Non-programming tools:
naps2 as graphical scanner app