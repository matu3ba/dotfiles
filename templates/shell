Purpose
Shell is a convenience cli and arbitrary complex scripting glue for
4 main goals:
- 1. piping
- 2. basic text processing
- 3. basic job control
- 4. path hackery.

There is a complete wiki dedicated to the weird quirks of bash:
https://wiki.bash-hackers.org/syntax/expansion/brace

SHENNANIGAN
- 1. brace expansion does only work on standalone variables:
  * "{1..3}" does not work, but {1..3} works
  * workaround for using in variables: `eval {$a..$b}`
  * workaround in for loops `for i in $(eval echo {$a..$b})`

SHENNANIGAN process spawning
- There is no standard way to signal a process is initialized to the parent process
- Shell has only quirky signaling ways: (named) pipe, (temp) file
  * Example: 'stty -F /dev/ttyS0 min 0 time 10 &' takes time to spawn

  > Yes, but why is this characterized as something negative?

SHENNANIGAN
Shells are not properly supported in any OS except plan9, since
- 1. the OS provides no enforcement or convention of CLI API interface (there
     is no enforced encoding standard or checkable stuff),
- 2. the OS provides no rules for file names to be shell-friendly and
- 3. there are no dedicated communication channels towards shells or in between
     programs and shells.
Thus, shells remain a hack around the system that is "simple to implement the
initials" and is annoying to use and write at many corner cases.

SHENNANIGAN
Escape unusual characters for usage, ie as shell variables:
find . -exec printf "%q\n" {} \;
find . -path RELPATH -exec printf "%q\n" {} \;
Note: This is very slow.

SHENNANIGAN find
only supports '-path RELATIVEPATH' forcing more typing

SHENNANGIAN
"Weaponizing Plain Text: ANSI Escape Sequences as a Forensic Nightmare" STÃ–K, Hacker
TODO summarize solutions
https://forum.defcon.org/node/245741
https://forum.defcon.org/node/245748
