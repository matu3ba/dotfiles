Memory in hardware

0-write optimizations analysis (not used due to introducing CVEs)
- which cache the filled regions fit in
- L3 performance gets weird
- Intel l2_lines_out.silent, l2_lines_out.non_silent shows L2 cache fills and
  evicted line triggered by L2 cache fill (MESI cache states)
- silent evictions => unmodified lines in E or S state, non-silent evictions in
  M, E or S state line with E and S being made in some unknown matter
- 0-writes to cache line already 0 get partial elided
- performance goes up from 60% (Skylake) to 96% (Icelake) for l2->l3 writebacks
  and from 20% (Icelake) up to 45% L3 and 25% RAM speedups (Icelake)
https://travisdowns.github.io/blog/2020/05/13/intel-zero-opt.html
https://travisdowns.github.io/blog/2020/05/18/icelake-zero-opt.html

memory models
1. synchronisation of memory from parallel execution works via fences https://stackoverflow.com/a/61711095
// Software Memory Models in C++
// memory_order | fences
// relaxed      | None
// consume      | LoadLoad, LoadStore (fences only for vars that are data-dependent on that atomic)
// acquire      | LoadLoad, LoadStore
// release      | LoadStore, StoreStore
// acq_rel      | LoadLoad, LoadStore, StoreStore
// seq_cst      | All (default order)
available via atomic_var.store(true, std::memory_order_release)
=> architecture-dependent and messy (stuff like spurious wakeups exist and costs can vary significantly)

2. pointer semantics: 3 cases to handle provenance
1. known and reused (no ambiguity on usage)
2. can be derived ie from pointer casts (pick one and check, if it works)
3. unknown (external code and no encoding of IR etc)
potentially ambiguous cases
1. ptr->int->ptr cast + usage
2. int->ptr->int cast + usage
3. ptr->int union cast usage
4. int->ptr union cast usage
see https://github.com/ziglang/zig/issues/6396#issuecomment-1097287569

3. simpler things?

CppMem: Interactive C/C++ memory model
http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/

Allocation classes
https://pzurita.wordpress.com/2015/06/29/memory-stomp-allocator-for-unreal-engine-4/
* memory allocation info to debug Memory 1. overrun, 2. underrun, 3. use after free
* works via tagging memory pages via OS (execute, read, write, and no-access) and
  using 2 pages with typically layout 1 for overruns or layout 2 for underruns:
  + 1. [empty space, alloc info, sentinel, allocation, page tagged as no-access].
  + 2. [page tagged as no-access, alloc info, sentinel, allocation, empty space (set with pattern)].
* Causes can also be UB https://www.gangofcoders.net/solution/what-is-a-memory-stomp/
