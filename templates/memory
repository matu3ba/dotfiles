memory models
1. synchronisation of memory from parallel execution works via fences https://stackoverflow.com/a/61711095
// Software Memory Models in C++
// memory_order | fences
// relaxed      | None
// consume      | LoadLoad, LoadStore (fences only for vars that are data-dependent on that atomic)
// acquire      | LoadLoad, LoadStore
// release      | LoadStore, StoreStore
// acq_rel      | LoadLoad, LoadStore, StoreStore
// seq_cst      | All (default order)
available via atomic_var.store(true, std::memory_order_release)
=> architecture-dependent and messy (stuff like spurious wakeups exist and costs can vary significantly)

2. pointer semantics: 3 cases to handle provenance
1. known and reused (no ambiguity on usage)
2. can be derived ie from pointer casts (pick one and check, if it works)
3. unknown (external code and no encoding of IR etc)
potentially ambiguous cases
1. ptr->int->ptr cast + usage
2. int->ptr->int cast + usage
3. ptr->int union cast usage
4. int->ptr union cast usage
see https://github.com/ziglang/zig/issues/6396#issuecomment-1097287569

3. simpler things?

CppMem: Interactive C/C++ memory model
http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/

Allocation classes
https://pzurita.wordpress.com/2015/06/29/memory-stomp-allocator-for-unreal-engine-4/
* memory allocation info to debug Memory 1. overrun, 2. underrun, 3. use after free
* works via tagging memory pages via OS (execute, read, write, and no-access) and
  using 2 pages with typically layout 1 for overruns or layout 2 for underruns:
  + 1. [empty space, alloc info, sentinel, allocation, page tagged as no-access].
  + 2. [page tagged as no-access, alloc info, sentinel, allocation, empty space (set with pattern)].
* Causes can also be UB https://www.gangofcoders.net/solution/what-is-a-memory-stomp/
