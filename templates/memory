Memory in hardware

0-write optimizations analysis (not used due to introducing CVEs)
- which cache the filled regions fit in
- L3 performance gets weird
- Intel l2_lines_out.silent, l2_lines_out.non_silent shows L2 cache fills and
  evicted line triggered by L2 cache fill (MESI cache states)
- silent evictions => unmodified lines in E or S state, non-silent evictions in
  M, E or S state line with E and S being made in some unknown matter
- 0-writes to cache line already 0 get partial elided
- performance goes up from 60% (Skylake) to 96% (Icelake) for l2->l3 writebacks
  and from 20% (Icelake) up to 45% L3 and 25% RAM speedups (Icelake)
https://travisdowns.github.io/blog/2020/05/13/intel-zero-opt.html
https://travisdowns.github.io/blog/2020/05/18/icelake-zero-opt.html

memory models
1. synchronisation of memory from parallel execution works via fences https://stackoverflow.com/a/61711095
// Software Memory Models in C++
// memory_order | fences
// relaxed      | None
// consume      | LoadLoad, LoadStore (fences only for vars that are data-dependent on that atomic)
// acquire      | LoadLoad, LoadStore
// release      | LoadStore, StoreStore
// acq_rel      | LoadLoad, LoadStore, StoreStore
// seq_cst      | All (default order)
available via atomic_var.store(true, std::memory_order_release)
=> architecture-dependent and messy (stuff like spurious wakeups exist and costs can vary significantly)

Out of thin air problem of C11/C++11 memory semantics
```Zig
const std = @import("std");
var X: i32 = 0;
var Y: i32 = 0;

fn inc1() void {
    const new = @atomicLoad(i32, &X, .Unordered);
    @atomicStore(i32, &Y, new, .Unordered);
}

fn inc2() void {
    const new = @atomicLoad(i32, &Y, .Unordered);
    @atomicStore(i32, &X, new, .Unordered);
}

pub fn main() !void {
    const t1 = std.Thread.spawn(.{}, inc1, .{});
    const t2 = std.Thread.spawn(.{}, inc2, .{});
    t1.join()
    t2.join()
    // out of thin value problem (below assertions could be wrong):
    // Load operations of 2 threads both see results of store operations of
    // other thread. store 37 in Y, because 37 is loaded from X, which was
    // stored to X because loaded 37 from Y, which is the value that was stored
    // in Y.
    std.debug.assert(@atomicLoad(i32, &X, .Unordered) == 0);
    std.debug.assert(@atomicLoad(i32, &Y, .Unordered) == 0);
}
```
Note: No optimization compiler implements consume ordering, because "dependent"
is hard to define and track along optimizations.

Compiler Fences, https://marabos.nl/atomics/memory-ordering.html

TODO continue at https://marabos.nl/atomics/hardware.html with assembly examples

Due to the lack of ordering guarantees, the load operations of these two
threads might both see the result of the store operation of the other thread,
allowing for a cycle in the order of operations: we store 37 in Y because we
loaded 37 from X, which was stored to X because we loaded 37 from Y, which is
the value we stored in Y.

2. pointer semantics: 3 cases to handle provenance
1. known and reused (no ambiguity on usage)
2. can be derived ie from pointer casts (pick one and check, if it works)
3. unknown (external code and no encoding of IR etc)
potentially ambiguous cases
1. ptr->int->ptr cast + usage
2. int->ptr->int cast + usage
3. ptr->int union cast usage
4. int->ptr union cast usage
see https://github.com/ziglang/zig/issues/6396#issuecomment-1097287569

3. simpler things?

CppMem: Interactive C/C++ memory model
http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/

Allocation classes
https://pzurita.wordpress.com/2015/06/29/memory-stomp-allocator-for-unreal-engine-4/
* memory allocation info to debug Memory 1. overrun, 2. underrun, 3. use after free
* works via tagging memory pages via OS (execute, read, write, and no-access) and
  using 2 pages with typically layout 1 for overruns or layout 2 for underruns:
  + 1. [empty space, alloc info, sentinel, allocation, page tagged as no-access].
  + 2. [page tagged as no-access, alloc info, sentinel, allocation, empty space (set with pattern)].
* Causes can also be UB https://www.gangofcoders.net/solution/what-is-a-memory-stomp/
