====model
====hardware
====kernel
====processes
====stack_unwinding_formats

====model
TODO list of formal models

====float
https://github.com/Traxar/various-number-types
would be cool to have some insight into what would be feasible for
semi-automatic debugging without full analysis

====hardware
debugging hardware probes TODO
debugging cpu https://zipcpu.com/zipcpu/2022/12/03/no-boot.html
debugging hardware https://zipcpu.com/blog/2024/11/06/not-axi.html
debugging the hard hardware stuff (FFT, crypto, ECC, compression) https://zipcpu.com/blog/2023/02/13/eccdbg.html
debugging best practice https://zipcpu.com/zipcpu/2022/08/30/not-my-fault.html
hardware verification https://github.com/YosysHQ/sby
* zipcpu has great quiz questions

scope probes

UART
* MCU, RX, TX, GND, cheap dongle
* uses printf which increases code size
* CPU or DMA setup cost
GDB/JTAG/SWD
* debug probe from affordable to thousands of dollar/euro
* dedicated JTAG/SWD pins without using up other pins: SWDIO, SWCLK, GND, JTAG/SWD debugger, usb
RTT
* dedicated JTAG/SWD pins without using up other pins: SWDIO, SWCLK, GND, JTAG/SWD debugger, usb
* uses printf which increases code size
* no peripherals from MCU, marginal CPU overhead due to using circular buffer in RAM
TODO other protocol trade-offs


oscilloscope + roboter for probing test points: Robotic Scope Probe
* unclear trade-offs and scalability

best practice:
* net-centric control of your DUT

https://intmainreturn0.com/notes/stacktrace-is-finally-cheap.html

====hardware_software
https://embeddedcomputing.com/technology/debug-and-test/debugging-at-the-hardware-software-interface
https://www.elektronikpraxis.de/hug-the-debug-bevor-es-zu-spaet-ist-a-1084581/
https://www.concept.de/products.html
https://www.einfochips.com/blog/debugging-of-mixed-signal-soc-in-an-effective-and-efficient-way-to-save-multi-billion-dollar-loss/
options:
* hardware sniffer / debug module
* SPICE with RNM blocks as mixed signal simulator
  - Ngspice (open source, todo look into features), ngspice
  - LTspice (good perf and features)
  - QSPICE (best perf and features)
  - todo look into debugging options

TODO summarize techniques in "Scalable Debugging for Data Centers: Ensuring Reliability from Design to Operations"

====processes
Linux: /proc
FreeBSD: procstat
==Files
procstat -f, fstat
==Network
FreeBSD: sockstat
Linux: ss

====kernel
idea https://shape.host/resources/advanced-kernel-debugging-techniques-on-linux
https://github.com/0voice/kernel_memory_management/blob/main/%E2%9C%8D%20%E6%96%87%E7%AB%A0/5%20useful%20tools%20to%20detect%20memory%20leaks%20with%20examples.md

TODO summarize methods mentioned in
https://www.brendangregg.com/blog/2024-03-17/the-return-of-the-frame-pointers.html

best practice long-running system design
https://arcan-fe.com/2020/02/10/leveraging-the-display-server-to-improve-debugging/
idea: make it cross-platform

* source requests debug session
* target checks permissions and sets capabilities via prctl
* forwards the request to src process

see also "Systemic Software Debugging"
tldr;

Debug Tooling
IDA Pro
- Hex-Rays decompilers

Core problem of abstraction in gdb:
- tui without any stability guarantee
- python scripting
- MI (machine interface)
  * requires parsing deeply complex and hostile data across privilege boundaries
- DAP (debugger adapter protocol)
  * usable for example in neovim

WinDbg and gdb with
- enhancement plugins such as peda pwndbg
- peda https://github.com/longld/peda
- pwndbg https://github.com/pwndbg/pwndbg

gdb
- posix gdb frontend https://github.com/nakst/gf

MSan, TSan
- bug discovery, crash deduplication, root cause analysis

Bochs x86 emulator
- very convenient instrumentation API, compatibility with the latest CPU
  features and ability to instrument entire operating systems

windbg
https://www.codeproject.com/articles/6084/windows-debuggers-part-1-a-windbg-tutorial

rad debugger
https://github.com/EpicGamesExt/raddebugger/
fast debugger partially inspired by RemedyBG, x86_64 Linux only, no ARM/macOS/fork support
https://github.com/al13n321/nnd

gdb process record
https://sourceware.org/gdb/wiki/ProcessRecord

https://docs.undo.io/ThreadFuzzing.html
logic based thread fuzzing for freezes (livelock, progress starvation etc)
* motivation not to use TSan https://undo.io/resources/gdb-watchpoint/using-threadsanitizer-to-debug-data-races/

process fuzzing based on linux scheduler?
unclear

hypervisor based debugging
* deterministic execution via Antithesis

would be very neat, if there would be either incremental object update over
network and/or linking both on source and target and use it for debugging.
unfortunately it does not look like rad debugger provides instructions how to
get to such a setup.

Unfortunately we have a huge pile of calling conventions=protocols in systems
in the field, which were also never designed with abi versioning in mind. And
to eliminate requires building competing platforms/protocols to replace
existing ones while being compatible for the meantime. I've never understood
why platforms with calling conventions offer no libraries to introspect
themself for user code debugging. at compiletime, runtime, linktime etc Instead
each compiler, debugger etc implements the same stuff again and again without a
reference impl
> i guess for C ABI, C compiler was the reference implementation. Though
> doesn't help with the introspection aspect - though to be fair designing
> first versions of C already had a lot of moving parts to handle, C ABI design
> probably didn't seem as high priority at first - had to get something working
> I think what can work though is establishing cycle of hacking together a tool
> that helps work better, create a better tool with the crufty tool, bootstrap
> the better tool back to the lower level that made it necessary to create the
> hacky tool in the first place. Kind of like lift to higher abstraction, work
> there, the lower back and improve the base layer so next time you already
> started at higher, better designed level

====hot_code_reloading
https://www.danielecarbone.com/hot-code-reloading/

====VS2022
https://www.youtube.com/watch?v=n5Pqn_wofmY
TODO

http://www.drchip.org/astronaut/drchipdbg/index.html
Charles Champbell also author of DrawIt vim plugin
inline debugger to filter collect traced code strings and print code
in sections or at statement level

====stack_unwinding_formats
https://maskray.me/blog/2025-09-28-remarks-on-sframe
* .sframe as lightweight alternative to .eh_frame and .eh_frame_hdr
* primary value proposition: enable frame pointer omission while preserving unwinding capabilities
  but only 1-2% size savings at cost of (without benchmarks) worse frame pointer unwinding perf
* future: getting irrelevant due to hardware-assisted unwinding like x86 Shadow Stack
  and AArch63 Guarded Control Stack
  TODO how do these work and what perf/size difference do they make?

TODO retrieve interesting debugging tooling https://blog.nelhage.com/post/computers-can-be-understood/
