Different types of Business model and tradeoffs in how to make money.
* Do It Yourself (DIY)
* Configuration As A Service (CAAS)
* Advice From Experience and Contract (AFEAC)
* idea catch phrase for hard to prove broken product domains (hardware vendors, etc)
* find something that isn't what everybody does and excel at that and be the first
one to do something (slightly) different
  o meaning finding a niche that is personally interesting and meaningful (to yourself/others)
  o open source means it must be meaningful to others, not only hype

====AFE

====CAAS
Example: Ethercat Product purpose is to have simple to extend electrical connections
with realtime characteristics in close to millisecond range down to 10-100us,
which is sufficient for many simple control applications.

However, developer experience is not great for REPL = fast debug cycles, which
may be typical or representative for "configuration as a service" products due
to incentives to not improve the build system to check validity of hardware
configurations and alike.

This includes router vendors, camera vendors etc.

====system_programming
"Systems programming" based on wikipedia.
"In computing, a virtual machine (VM) is the virtualization or emulation of a computer system."
"The term computer system may refer to a nominally complete computer that
includes the hardware, operating system, software, and peripheral equipment
needed and used for full operation; or to a group of computers that are linked
and function together, such as a computer network or computer cluster."
But on itself, "A computer is a machine that can be programmed to
automatically carry out sequences of arithmetic or logical operations
(computation)."

Computer system therefore sounds very much like managing runtime (=scheduler +
resource management on one or multiple computers) + peripherals directly or
indirectly (IO).
https://en.wikipedia.org/wiki/Systems_programming mentions 1. target specific
and/or 2. low abstraction of target and/or 3. not or hard to debug.
One can therefore argue that all domain specific programming without the need
of any hardware or kernel knowledge would be non-system and the rest system
programming.