https://nullprogram.com/blog/2015/05/15/ how clone() works

get Kernel compilation+runtime config
cat /proc/config.gz | gunzip > running.config
ls /boot/config-*
ls /usr/src/linux*

Watching based on notify events:
inotifywait -e modify,create,delete -m -r /path/to/your/dir

Get list of open files from process
lsof
Get list of locked files
lslocks

Monitor changes based on inode level (application must change directory
inode on file insertion, so one might miss events):
auditctl -w <path> -p <permissions> -k <key>
ausearch -f <path>
ausearch -k <key>
auditctl -l
auditctl -W <path>

sleep 10m && systemctl suspend
Get the logs
journalctl -n 200

auditd (access monitoring framework)
bpftrace (general tracing solution to create + run ebpf programs)
idea: usage with monitoring, is bcc necessary?

Trace systemcalls: strace ./binary
Common options
    -c – Rough estimation of what time is spend and where (use -S for sorting)
    -f – Track process including forked child processes
    -o my-process-trace.txt – Log strace output to file
    -p 1234 – Track process by PID
    -P /tmp – Track process when interacting with path
    -T – Print time spent in each syscall
    -t - Prefix trace with Wall time
Track by specific system call group
    -e trace=%ipc – Track communication between processes (IPC)
    -e trace=%memory – Track memory syscalls
    -e trace=%network – Track memory syscalls
    -e trace=%process – Track process calls (like fork, exec)
    -e trace=%signal – Track process signal handling (like HUP, exit)
    -e trace=%file – Track file related syscalls
    -e trace=%desc - Trace descriptor related system calls
    -yy, --decode-fds=all - Print all available information associated with file descriptors

To trace file descriptor info, use
strace -f -e trace=%desc -yy CMD
strace -f -e trace=%desc -yy ./build/stage3/bin/zig build -Dtest-filter=test/standalone/child_process/build.zig test-standalone &> debug.strace
strace -f -e trace=%desc -yy ./relbuild/stage3/bin/zig build -Dtest-filter=test/standalone/child_process/build.zig test-standalone &> release.strace
To trace children and with file descriptor info
strace -ff -yy

Trace and debug system ressources (memory, file descriptors etc): Valgrind
    -v                              increase verbosity level
    --vgdb=no|yes|full [yes]        Allow external gdb to control program
    --trace-children=yes|no [no]
    --track-fds=yes|all|no [no]
    --time-stamp=no|yes
    --log-fd=nr [2=stderr]
    --log-file=file (%p PID for multiple processes, %n for several files from same filename)
    --log-socket=ip:port
Most used Memcheck
    --leak-check=full|no|summary [summary]
    --track-origins=yes|no [no]     Show origins of undefined values
    --read-var-info=yes|no [no]     Read debug info on stack and global vars to
                                    Print better error messages
Error related options
    --quiet                         Only show real errors, not pedantic (like fds 012 not closed)
    -s shorthand for --show-error-list=yes  Show errors as list

To trace child processes, use
valgrind -s --trace-children=yes --track-fds=all --log-file=debug_%n.log CMD
valgrind -s --trace-children=yes --track-fds=all --log-file=debug_%n.log ./build/stage3/bin/zig build -Dtest-filter=test/standalone/child_process/build.zig test-standalone

Accurate Performance measuring:
sudo perf stat -r 10 -d alacritty -e false
Less noise with:
https://github.com/andrewrk/poop/issues/39
https://github.com/lpechacek/cpuset
TODO commands
Estimations:
https://www.uops.info/
better: https://uica.uops.info/
pile of assembly manuals
https://www.agner.org/optimize/

Hot/Cold Flame Graphs (separate, mixed, integrated)
git clone https://github.com/brendangregg/FlameGraph
cd FlameGraph

perf record -g build
perf script > out.perf
./stackcollapse-perf.pl out.perf > out.folded
./flamegraph.pl out.folded > flamegraph.svg

Hardware locality info extraction and experimenting:
https://github.com/open-mpi/hwloc

https://github.com/flamegraph-rs/flamegraph
which has also a nice guide.

Portable performance estimation (simulation of execution + cache behavior):
(Valgrind analysis makes code 10x-100x slower)
callgrind collects statistics about cache misses, callgrind extends function info
valgrind --tool=callgrind --fn-skip="0x*" --fn-skip="llvm*"

KCachegrind visualizes performance in a callgraph, callee map, source code and machine code views
* requires X11 and KDE libs
requires --dump-instr=yes|no
--simulate-cache=[yes|no]
--callgrind-out-file=<file>
valgrind --tool=callgrind --help

Determine cache hierachy and line size on CPU with 'lstopo', ie with
* lstopo - -v --no-io
* TODO Intel Performance guides says cache lines are loaded and stored in 128B chunks

Workaround hugepage Kernel bug:
https://unix.stackexchange.com/questions/679706/kcompacd0-using-100-cpu-with-vmware-workstation-16
cat /sys/kernel/mm/transparent_hugepage/enabled
cat /sys/kernel/mm/transparent_hugepage/defrag
echo 0 > /proc/sys/vm/compaction_proactiveness
sudo sh -c 'echo 0 > /proc/sys/vm/compaction_proactiveness'

Sandboxing
Fixing Desktop GPU + IPC design problems (for example making dbus superfluous): aracan-fe
Desktop sandboxing to reduce gigantic attack vector: firejail
Tight sandboxing: bubblewrap
firejail:
configs in /etc/firejail/, /usr/local/etc/firejail, ~/.config/firejail
tools in /usr/lib/firejail, /usr/local/lib/firejail

Storage (block and flash) device troubleshooting
Parted
sudo parted
print devices
select /dev/sdX
> Warning: Unable to open /dev/sdf read-write (Read-only file system).  /dev/sdf has been opened read-only.
sudo chmod -R 777 /dev/sdX
> if error: sudo chown -hR $(whoami) /dev/sdX
sudo mount -orw,remount /dev/sdX

Kernel view of sdcard/block device:
sudo hdparm -r0 /dev/sdX
/dev/sdX:
 setting readonly to 0 (off)
 readonly      =  1 (on)
 External reasons
 - 1. dip switch set to readonly
 - 2. incorrect positioning or faulty reader
 - 3. internal component detected fault

Time settings locally
sudo hwclock --show --utc
sudo timedatectl set-timezone Europe/Berlin
sudo date -s "3 MAR 2023 09:29:00"
Set settings from host to target
sudo timedatectl set-timezone Europe/Berlin
ssh user@domain@ip sudo timedatectl set-timezone Europe/Berlin
ssh user@domain@ip sudo date -s @$(date -u +"%s")

systemctl status systemd-timesyncd
journalctl -u systemd-timesyncd
systemctl --user unmask pulseaudio pulseaudio.socket
systemctl --user status pipewire pipewire-pulse pulseaudio pulseaudio.socket

harddrive - storage device problems
https://askubuntu.com/questions/144852/cant-format-my-usb-drive-i-have-already-tried-with-mkdosfs-and-gparted/933035#933035
1. lsblk / lsusb etc dont show device
2.

show process tree
ps -ef --forest
pstree

kernel memory usage inaccuracies + gdb memory inspection
https://tbrindus.ca/sometimes-the-kernel-lies-about-process-memory-usage/
sandbox performance + ptrace
https://tbrindus.ca/on-online-judging-part-1/

DeviceTree (x86 uses different names for devicetree like ACPI tables, PCI enumeration, USB etc)
https://unix.stackexchange.com/questions/289563/how-to-list-the-kernel-device-tree
evice-tree-compiler
dtc -I fs /sys/firmware/devicetree/base
find /proc/device-tree/ -type f -exec head {} + | less

https://github.com/quark-zju/lrun

How to debug linux Kernel with gdb and qemu
https://stackoverflow.com/questions/11408041/how-to-debug-the-linux-kernel-with-gdb-and-qemu/33203642#33203642

Program start in the Kernel on Posix summarized from https://lwn.net/Articles/631631/
and https://lwn.net/Articles/519085/ on example of exec(ve)
1. ELF file for executable (rather than shared library or object file) must contain program header table after ELF header
2. Kernel only cares about 3 segments:
  * 1. PT_LOAD (areas of the new program's running memory including code and data sections [including BSS to be zerod]),
  * 2. PT_INTERP identifiying runtime linker
  * 3. PT_GNU_STACK to indicate, if stack should be made executable or not
3. Tear down old state
4. Setup of all the things
5. Stack population including the auxiliary vector, environment and arguments
  * 'LD_SHOW_AUXV=1 sleep 1000'
  * 'cat /proc/PID/auxv > auxvals'
  * 'od -t d8 /proc/PID/auxv'
  * #include <sys/auxv.h>
    unsigned long int getauxval(unsigned long int type);
