CASR: Crash Analysis and Severity Report
AFL: Fuzzing crashes

====basics

Micro-Kernel: Nothing enabled on default with user needing to setup things.
Mono/Uni-Kernel: Most things enabled on default with user needing to disable things.
Design of Uni-Kernel alone makes less unsecure due to less isolation of components.

Note: Linux is becoming more Micro-Kernel-like with io_uring as 0-copy messaging,
bpf as VM running statically compiled code inside Linux etc.

Proof code effort is quadratic to code size:
* Bug hidden for any non-trivial or verified implementation.
* Use the simplest approach possible, isolate components
* If unfeasible to rule out intruders, you must monitor and mitigate including
  all related costs.
* Plan for the worst case

=> seL4 would be ideal to use, but maybe there is a tradeoff to allow some
more monitoring or control on the host system ie to debug the VM?

Timing channels in protocols are a huge problem
* using wireguard instead of openVPN to run ssh over it does not eliminate the
  timing channel
* must analyze frequencies, meaning plot a few dimensions against time, like
  packet size, length on router level for whatever tool you are suspicious off.
* Interact and try to identify differences (patterns etc).

idea examples or tools to for time analysis (io, network etc)

====applied_basics

basics https://phoenixnap.com/kb/server-security-tips

====jail

1. wireguard + ssh (on another port)
  * (dynamic) port forwarding and all those things
  * TODO
2. sandboxed environment (jails, zones, containers)
  * whitelist of Kernel calls
  * file system overlay
  * ulimit or cgroups pendant
  * landlock
  * network access removed (routing, connection interfaces etc)
  * cpu, io, memory limits
  * max. execution time
  * no clipboard access etc
  * no login manager entry
  * paging (disable Kernel Samepage Merging)
  * cgroups, apparmor, selinux needed?
  * paging (disable Kernel Samepage Merging)
3. unprivileged user
4. coredump + stack trace obtainable,
5. reaper pid to kill child processes
6. restricting ptrace to only 1 process required selinux policy
https://serverfault.com/questions/933205/selinux-policy-for-cap-sys-ptrace-by-invoking-process-name,
but should work now in landlock:
https://docs.kernel.org/userspace-api/landlock.html#ptrace-restrictions
"To be allowed to use ptrace(2) and related syscalls on a target
process, a sandboxed process should have a subset of the target process rules,
which means the tracee must be in a sub-domain of the tracer."
Unfortunately it does not say "must have".
7. disable hyperthreading (in bios)
8. hardened kernel?

====virtualization

Note: Without kvm qemu is very slow and with kvm qemu has a huge attack surface
from the guest OS.

* qemu qmp (or use qemus gdb stub) to read the vm's memory
* attach serial channel to qemu machine and write stuff to that (treat the read bytes as plain and potentially malicious data)

====allocators

Preventing Use-After-Free Attacks with Fast Forward Allocation
* overhead in runtime perf vs glibc
  + allegedly ~2.3% for one-time allocations
  + up to 35% due to mmap-sem lock in Linux kernel
  + ~60% memory overhead
  + nginx testing with comparable throughput
* lesson: One-time-allocation effective + simple to implement
