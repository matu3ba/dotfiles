====types
====dataflow_systems
====distributed_double_accounting_databases
====query_compilation
====relational_database
====replication
====usability
====vector_databases
====performance
====consistency

====types
Datomic - temporal Entity-Attribute-Value OLTP database https://jepsen.io/analyses/datomic-pro-1.0.7075
* Keeping CALM: When Distributed Consistency is Easy
* https://dtornow.substack.com/p/jepsen-and-tigerbeetle

====dataflow_systems
* aqualang as language designed to be compositional, safe, fast, easy to use
  - uses equality saturation for optimizations

====distributed_double_accounting_databases
tigerbeetle

====query_compilation
Database query compilation: our journey Thomas Neumann & Viktor Leis
* trade-offs on query execution
Simpler alternative to use REST on postgresql https://github.com/PostgREST/postgrest
* likely slower, uses haskell

====relational_database
* structured query language (sql)
  - bigquery, zetasql, etc (pipe syntax for composability)
  - prql (pipelined relational query language) as "modern sql replacement" for composability
    o transforms, orthogonalisms, invariants, few primitives, fns, ergonomics
    o clickhouse, duckdb, glaredb, mysql, postgres, sqlite, ansi, bigqueue, mssql, snowflake
* performance tuning
  - reduce table size
  - simplify and omit if possible joins
  - (postgresql) to get runtime of query prefix it with EXPLAIN
  - TODO many more things
* https://dikmenonur.medium.com/sql-performance-tuning-a-comprehensive-guide-0e8a0b0b8aa9

====replication
"Enough with all the Raft" by Alex Miller
* Blob Storage
* Quorum
* Raft
* Reconfiguration

====usability_shortcomings
"DB usability as if" by Jonathan Edwards
* displaying relationships
* interactive schema evolution (DSLs in research, but no interactivity)
* version control for data and schema

====vector_databases
https://grski.pl/vdb

unclear use cases of http://www.logicblox.com/learn.html

====performance
data bases restrict data flexibility (ie opc-ua) for better perf + synced storage
general rule: must measure
* ACID
* BASE/non-ACID (dont care that data is trustable) like get latest value asap
  - key/value stores
  - time series dbs
  - TODO what more?
  - only useful in distributed cases to sidestep costly locking
  - Early Mongo was shiny JSON-shaped memcached (key-value store)
  - time spent in app: postgres: first needs deserialize db response, then deserialize jsonb seperately
* data points
  - uncontended/no locks
    + mongo db 50k samples/s

====consistency_models
* should simpler than CPU consistency models, but I am unaware of any reasoning
https://en.wikipedia.org/wiki/Consistency_model
https://jepsen.io/consistency/models
for concurrent/distributed systems
* no justification why only these properties were chosen, probably because simpler and applicable to distributed systems
read uncommitted -> read commited -> monotonic atomic view
  (total available: available on every non-faulty node, even when network completely down)
cursor stability -> repeatable read -> serialize -> strict serializable/consistency
                    ^                                 ^
snapshot isolation /                    linearizable /
                                           ^
                               sequential /
  (unavailable: not available during some type of network failures, some or all nodes must pause operations)
read your writes -> PRAM -> causal
  (sticky available: available on every non-faulty node, as long as clients talk to same server instead of switching to new)

  * CPU also has: PRAM -> processor -> sequential
  * CPU also has: cache -> processor, incomparable with PRAM
  * CPU also has: slow -> cache | processor

Coherence deals with maintaining a global order in which writes to a single
location or single variable are seen by all processors. Consistency deals with
the ordering of operations to multiple locations with respect to all
processors.

https://jepsen.io/consistency/models is interesting, because it omits many CPU
synchronization models without elaborating and does the same for distributed
system models, when one reads the analysis reports (which is quite a bit
frustrating). https://en.wikipedia.org/wiki/Consistency_model is similar
chaotic. Does there exist any non-chaotic collection of CPU sync models?
