https://www.fpga-conference.eu
https://vhdlwhiz.com/terminology

====standards
====tooling
====learning

====standards
* UVVM as fastest growing HDL verification methodology
  - includes requirement tracking for VHDL testbenches
* microcontrollers with security features: Cyber Resilience Act (CRA) class I
  - wip standard
* Harmonized FPGA Module (HFM) as open standard for FPGA and SoC-FPGA System-on-Module (SoM) designs
* Precision Time Protocol (PTP) software stacks down to sub-nonsecond time alignment
  - via dedicated semiconductor timing devices

====tooling
vunit
hog (hdl-ongit) as set ot tcl/shell scripts
Open Source VHDL Verification Methodology (OSVVM): https://github.com/OSVVM/OsvvmLibraries
Open Logic as fastest-growing open-source HDL standard library: https://github.com/open-logic/open-logic
Co-Simulation environments: Cocotb
UVVM provides a structured approach with powerful testbench utilities and
verification components, while VUnit enhances automation,  advanced test
management, and continuous integration support.

====learning
1 Basics FGPA and Zynq SoC
Start with HDLs like Verlog, VHDL or SystemC. Understand unique architecture
of Zynq SoC — ARM processor + FPGA fabric.
* https://www.fpga4student.com/
* Project F — Tutorials Vivado + Verilog https://projectf.io
* ZipCPU Blog, logic design and bus protocols https://zipcpu.com
2 Deep dive
* lean Processing System (PS) and Programmable Logic (PL) interaction with Zynq
* Xilinx / AMD Blogs — Vitis, Vivado and Zynq-specific projects
  - https://www.xilinx.com/blog
  - Tutorials focused on Zynq boards https://digilent.com/blog/
3 Get comforable with key communication protocols
* UART, SPI, I2C for peripheral communication, AXI for PS-PL data exchange
* Ethernet and AXI DMA next as you advance
4 Explore real projects and community repos
* ADI EngineerZone — Zynq designs with SPI, JESD204, and more
  - ADI GitHub — Real FPGA communication systems https://ez.analog.com
  - https://github.com/analogdevicesinc
  - Hackster.io — Community-driven DIY projects https://hackster.io
* begin with UART, SPI for example starting with zynq nano board

====trade-offs
* ASIC
  - same as FGPA but very high compilation time and initial production tooling costs
* FGPA
  - self-made cache
  - high synthesis time, no wrong code accepted (solving worse than exponential time due to many constrains and synthesis choices)
  - performance, area, and power for cycle-perfect timing
  - configurable gate synthesis
    o 1 not worth complexity
    o 2 emulation/simulation/verification etc with ASIC mindset of RTL much faster
    o 3 libraries usage etc advised
    o Background https://semiengineering.com/fpga-design-tradeoffs-getting-more-difficult/
    and https://www.ansys.com/de-de/simulation-topics/what-is-register-transfer-level-design
* CPU
  - given fixed cache
  - low compilation time (compiler take shortcuts potentially creating broken instructions, no slow to fullfill constrains)
  - estimation- + env-based perf, flexible power, in some areas no; others fewer timing guarantees
