HACK
TODO
FIXME

c/c++
cpplint, flawfinder, clang-tidy
hefty dependency: oclint

`clang-tidy -checks='bugprone-*,cert-*,clang-analyzer-*,cppcoreguidelines-*,hicpp-*' file.c -- [clang[++]|gcc|g++]-flags`
`hicpp-*` occasionally must be disabled.
`misc-*` opinionated
`modernize-*` bad for C interop (use 0 instead of nullptr to interop with C)
`performance-*` depends
`portability-*` depends
`readability-*` opinionated

isOverlapping( for [start,end) intervals]:
assume: intervals
       | |
     | |
dont overlap, xa < xb and ya < yb
      ya       yb
      |--------|
xa |--|xb
   |----|
         |----|
ya > xa => ya - xa < xb - xa ?
else    => xa < yb ?

intersection( for [start,end) intervals]:
[max(xa,ya),min(xb,yb)]

With above formula, detecting overlaps of a recurring timer interval and an absolute one:
Given fixed interval [    ]  and variable interval [  ]
                     ya   yb                       xa xb
1. overlap, if ya > xa => ya - xa < xb - xa ?
2.             ya <=xa => xa < yb ?
case 1:
search for last timestep with xa < ya:
    xa + x*reocc <= ya
<=>           x  <= (ya-xa)/reocc
<=>           x  = btm((ya-xa)/reocc)
<=>           x  = (ya-xa)/reocc  [for integers]
and manually check, if xa + x*reocc == ya.
If not: check ya - xa < xb - xa ? (then overlap with x).
case 2:
search for first timestep with xa >= ya:
    xa + x*reocc >= ya
<=>           x  >= (ya-xa)/reocc
<=>           x  = ceil((ya-xa)/reocc)
<=>           x  = (ya-xa+1)/reocc  [for integers]
        check xa < yb ?

Always use SI units or other units, if possible and not clear from context.
This does also include generics.

Good Abstraction: Criteria
- common?
- useful?
- restrictions?
- coupling?
- composable?
Good Abstraction: How?
* bottom-up design: start with application code to inform lib
* null hypothesis: dont use a lib, then develop one


Github issues
```
PID=$(pgrep PROGRAM) && sudo -E capsh --caps="cap_setpcap,cap_setuid,cap_setgid+ep cap_sys_ptrace+eip" --keep=1 --user="$USER" --addamb="cap_sys_ptrace" --shell=/usr/bin/gdb -- -p $PID
thread apply all backtrace full |& tee backtrace.log
```
<details>

```

```

</details>

  max_step
   |   |
|  m1  m2      |
0              MAX
wraparound counter with limited step length assumption of
assume: correct + continuous connection + value retrieval
6 cases:
* m1 = m2 => 1. no change
* m1 < m2
  * m2 - m1 < max_step => 2. plus
  * MAX-m2+m1 < max_step => 3. wraparound_minus
* m2 < m1
  * m1 - m2 < max_step => 4. minus
  * MAX-m1+m2 < max_step => 5. wraparound_plus
* otherwise => 6. unclear

0. extended_counter = extended_counter;
1. extended_counter += (m2 - m1)
2. extended_counter = extended_counter & 0xffffffff - (2<<32) + m2
3. extended_counter -= (m1 - m2)
4. extended_counter = extended_counter & 0xffffffff + (2<<32) + m2

Explanation case 2:
   2         7
|  m1        m2      |
0                   MAX
before = 2 (22)
cnt = 7 (17)
MAX=9
cnt = log_MAX(cnt) - (MAX+1) + m2
cnt = 22 - (10) + 7
    = 20 - (10) + 7
    = 17
=>    u32mask(cnt) - U32MAX + m2

Explanation case 4:
   2         7
|  m2        m1      |
0                   MAX
m1 = 7 (17)
m2 = 2 (22)
MAX=9
cnt = log_MAX+1(cnt) + (MAX+1) + m2
cnt = log_MAX+1(17) + (10) + 7
    = 10 + (10) + 7
    = 17
=>    u32mask(cnt) + U32MAX + m2
