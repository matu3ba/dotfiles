Taken from nix.dev. Nix pills is another good source. Unfortunately flakes have
no good docs yet and I found nothing good for debugging (overlays).

Reproducible ad-hoc environment
nix-shell -p git --run "git --version" --pure -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/2a601aafdc5605a5133a2ca506a34a3a73377247.tar.gz

Reproducible interpreter scripts
v nixpkgs-releases.sh
#! /usr/bin/env nix-shell
#! nix-shell -i bash --pure
#! nix-shell -p bash cacert curl jq python3Packages.xmljson
#! nix-shell -I nixpkgs=https://github.com/NixOS/nixpkgs/archive/2a601aafdc5605a5133a2ca506a34a3a73377247.tar.gz
curl https://github.com/NixOS/nixpkgs/releases.atom | xml2json | jq .
^

Nix language basics
nix repl
:p { a.b.c = 1; }
nix-instantiate --eval --strict file.nix
let x=1;y=2;in x+y
attributes dont need quotes, list sep is whitespace
access attributes from within set:
rec { one = 1; two = one + 1; three = two + 1; }
assign names to values for repeated usage:
let a = 1;
in a + a
attributeset access (nested works identical):
let attrset = { x = 1; };
in attrset.x
instead of writing out [a.x a.y] use with:
let a = { x = 1; y = 2; };
in with a; [ x y ]
inherit values, ie `x = a.x; y = a.y;`:
let a = { x = 1; y = 2; };
in { inherit (a) x y; }
string interpolation works like python f-strings:
let name = "Nix";
in "hello ${name}"
beware of $var being a shell variable.
search paths (to be avoided for predictable outcomes):
<nixpkgs/lib>
multiline strings:
''
s1
s2
''
fns have no names and are lambdas:
x: x + 1
x: y: x + y
{ a, b }: a + b
{ a, b ? 0 }: a + b
{ a, b, ...}: a + b
named set attribute:
args@{ a, b, ... }: a + b + args.c
assign fn to a name:
let f = x: x + 1; in f
calling fn:
let f = x: x + 1; in f 1
let f = x: x.a; in f { a = 1; }
let
  f = x: x.a;
  v = { a = 1; };
in f v
(x: x + 1) 1
beware the difference:
let
 f = x: x + 1;
 a = 1;
in [ (f a) ]
in [ f a ]
multi args (curried fns):
x: y: x + y
x: (y: x + y)
return fn y: x+y with x set to 1:
let f = x: y: x + y; in f 1
return 3 from fully evaluating fn:
let f = x: y: x + y; in f 1 2
constrain allowed args structure (adding c=3 not allowed):
let f = {a, b}: a + b;
in f { a = 1; b = 2; }
default values:
let f = {a, b ? 0}: a + b;
in f { a = 1; }
additional attributes:
let f = {a, b, ...}: a + b;
in f { a = 1; b = 2; c = 3; }
named attribute set arg:
let f = {a, b, ...}@args: a + b + args.c;
in f { a = 1; b = 2; c = 3; }
fn libraries (besides built-in operators) in C++:
* builtins (Built-in fns)
import (alterntive default.nix) with result 3:
$echo 1 + 2 > file.nix
import ./file.nix
$echo "x: x + 2" > file.nix
import ./file.nix 1
pkgs.lib in nix:
let pkgs = import <nixpkgs> {};
in pkgs.lib.strings.toUpper "search paths considered harmful"
impurities to observe outside world:
* build inputs available via 1. file system paths, 2. dedicated fns
* are refered to by their content hash
paths:
echo 123 > data
"${./data}"
"/nix/store/h1qj5h5n05b5dl5q4nldrqq8mdg7dhqk-data"
fetchers:
* builtins.fetchurl|fetchTarball|fetchGit|fetchClosure
* evaluate to file system path in nix store
builtins.fetchurl "https://github.com/NixOS/nix/archive/7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz"
"/nix/store/7dhgs330clj36384akg86140fqkgh8zf-7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz"
derivations:
* nix is used to describes derivations
* nix derivations to produce build results
* build results can be used as inputs to other derivations
let pkgs = import <nixpkgs> {};
in "${pkgs.nix}"

Pinning nixpkgs
pick commit from status.nixos.org
{ pkgs ? import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/06278c77b5d162e62df170fec307e83f1812d94b.tar.gz") {}
}:
..

Using niv (to track nix unstable):
nix-shell -p niv --run "niv init"
niv show
niv modify nixpkgs --branch nixos-21.05
{ sources ? import ./nix/sources.nix, pkgs ? import sources.nixpkgs {}
}:
..
nix-shell -p niv --run "niv update"

Declarative and reproducible developer environments
* set shell env vars
* exec bash cmds during activation
* share exact environment with other devs
Minimal shell.nix:
{ pkgs ? import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/06278c77b5d162e62df170fec307e83f1812d94b.tar.gz") {} }:
pkgs.mkShell {
  buildInputs = [ pkgs.which pkgs.htop pkgs.zlib ];
  shellHook = "echo hello";
  MY_ENVIRONMENT_VARIABLE = "world";
}
More useful shell.nix:
{ pkgs ? import (fetchTarball "https://github.com/NixOS/nixpkgs/archive/eabc38219184cc3e04a974fe31857d8e0eac098d.tar.gz") {} }:
pkgs.mkShell {
  packages = [
    (pkgs.python3.withPackages (ps: [
      ps.flask
    ])) pkgs.curl pkgs.jq
  ];
}
direnv:
echo "use nix" > .envrc && direnv allow

Sharing dependencies between default.nix and shell.nix
TODO

TODO remove the useless crap

effortless dev environment changes
https://cbailey.co.uk/posts/my_usage_of_nix_and_lorri__direnv

non-nix system:
something broke
DONT USE THIS AS THIS PINS YOUR DEPENDENCIES ON SPECIFIC VERSION
nix-env -f '<nixpkgs>' -iA nixUnstable
nix-channel --udpate

====home-manager
manages ${HOME}
should be used as standalone to work everywhere, where nix works
without this impurities may creep in
temporary usage: nix-shell -p gnumake -p python27

====flakes
project-specific setups, overlays etc

====profiles
not platform-independent and do not work anywhere you have nix

nix shell 'github:nixos/nixpkgs/nixpkgs-unstable#hello'
nix build 'nixpkgs#hello'
nix develop 'nixpkgs#hello'

nix profile install 'nixpkgs#hello'
nix profile list
nix profile update hello
nix profile remove hello

nix flake show
nix flake clone
nix flake lock
nix flake lock –override-input input_name
nix flake lock –update-input input_name

# Flakes allow you to specify your codes dependencies
# (e.g. remote Git repositories) in a declarative way,
# simply by listing them inside a flake.nix file
nix flake lock --update-input home-manager

For installation andd the basic introduction, read "practical nix flakes".
https://ghedam.at/a-tour-of-nix-flakes is the best flakes introduction so far, which
also does not use "legacyPackages".
As of 20220620,
nix has no good solution to define relative flakes for not cluttering the git history:
https://discourse.nixos.org/t/locally-excluding-nix-flakes-when-using-nix-independenly-of-upstream/16480/19
The current options are `git add -N` (adding to git commit) and `path:$(pwd)` (copies over whole path)
or `path:.`.

It is very unfortunate that this was introduced without a fallback until there are good tutorials.
```txt
$ nix develop
warning: Git tree '/home/user/dev/git/zig/zig/master' is dirty
error: getting status of '/nix/store/17iqqnm1l9admxzbpc9rgdz7fq7pkr2y-source/flake.nix': No such file or directory
```

Looking very useful:
https://github.com/nh2/nixos-vm-building
https://github.com/m-bdf/nixos-init-freedom
https://github.com/cachix/devenv
https://github.com/tweag/nickel, successor to nix, but very early mvp 0.1

Probably nicest book yet for flakes but not complete and structured:
https://nixos-and-flakes.thiscute.world/

https://blog.wesleyac.com/posts/the-curse-of-nixos
bad:
- 1. own programming language, complicated and annoying to understand
- 2. no real isolation (only path hackery), but overlayfs on Linux itself has many limitations (paths and stacking)
  * related to core design issue of Linux (Unix file permission system), which stores permission of user and group in each file

More interesting projects
embedded OS https://github.com/cleverca22/not-os

Features, which can be considered as missing from nix:
- namespace control tools :
  * why can't you do different hierarchies (see: GoboLinux, djb's /package, or even a completely custom one)
  * why mixing different alternatives: service managers, libc's, or even compile flags is still so difficult)
- package categories (missing metadata)
  * play market/app store figured this out 10, 15 years ago, why do we still resort to external search engines
- a non-DSL programming language (guix seems to do just that, but it's hopelessly corrupted by GNU-no-firmware philosophy)
- portability
  * no systemd,
  * no Linux-only features
  * option to put packages in ISO's, qcow2's, plain old tarballs (see root tarballs, or OpenBSD's site*.tgz)
    + winetricks doesn't need it's own dxvk's, directx's, and faudio's etc
